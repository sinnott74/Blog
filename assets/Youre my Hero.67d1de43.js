var n=Object.defineProperty,e=Object.getOwnPropertySymbols,o=Object.prototype.hasOwnProperty,r=Object.prototype.propertyIsEnumerable,i=(e,o,r)=>o in e?n(e,o,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[o]=r;import"./vendor.0d5e54d3.js";import{N as t}from"./mdx-react.modern.650372c4.js";const l="You're my Hero",a="Daniel Sinnott",c="https://i.imgur.com/ZVaDnJx.png",g=22,f=["Technical","Golang"],s="Fri, 24th Aug 2018",x=new Date(1535113913699);function p(n){var l=n,{components:a}=l,c=((n,i)=>{var t={};for(var l in n)o.call(n,l)&&i.indexOf(l)<0&&(t[l]=n[l]);if(null!=n&&e)for(var l of e(n))i.indexOf(l)<0&&r.call(n,l)&&(t[l]=n[l]);return t})(l,["components"]);return t("wrapper",((n,t)=>{for(var l in t||(t={}))o.call(t,l)&&i(n,l,t[l]);if(e)for(var l of e(t))r.call(t,l)&&i(n,l,t[l]);return n})({components:a},c),t("p",null,"When I decided to redesign the home page of this blog to include an image with every post, I was\nfaced with the reality that I'd need to have a new ",t("a",{href:"https://en.wikipedia.org/wiki/Hero_image",parentName:"p"},"Hero Image")," for every post and that I'm not a\ngraphic designer..."),t("blockquote",null,t("p",{parentName:"blockquote"},"In web design, a hero image is a large web banner image, prominently placed on a web page,\ngenerally in the front and center. The hero image is often the first visual element a visitor\nencounters on the site; it presents an overview of the site's most important content.")),t("p",null,"Having played around with ",t("a",{href:"https://www.gimp.org/",parentName:"p"},"Gimp")," for a few days it became readily apparent that I'd need a way to\n",t("strong",{parentName:"p"},"create Hero images quickly")," and with a consistent style. I'd need to build something. GUIs can\ntake a long time to perfect so a quick and dirty command line utility was my best option. Lets ",t("a",{href:"https://golang.org/",parentName:"p"},"GO"),"!"),t("h2",null,"Golang Command Line Utility"),t("p",null,t("img",{src:"https://i.imgur.com/IcyLOyC.png",alt:"Golang",title:"Golang",parentName:"p"})),t("blockquote",null,t("p",{parentName:"blockquote"},"Go is a statically typed, compiled language in the tradition of C, with memory safety, garbage\ncollection, structural typing, and CSP-style concurrency.")),t("h3",null,"Getting Started"),t("h4",null,"Install Go"),t("p",null,"Follow the instructions at ",t("a",{href:"https://golang.org/doc/install#install",parentName:"p"},"install Golang")," for your operating system"),t("p",null,"Go is the perfect language to create a command line utility. It compiles into a single binary, has a\ngreat standard library & excellent cross platform support."),t("h4",null,"Install Cobra"),t("p",null,"Although the standard library has everything we need to create our utility, we're going to use\n",t("a",{href:"https://github.com/spf13/cobra",parentName:"p"},"Cobra")," to simplify things. Cobra is a great tool and library used by the likes of Docker,\nKubernetes and Openshift to create command line applications."),t("p",null,"To install Cobra run"),t("pre",null,t("code",{className:"language-go",parentName:"pre"},"go get github.com/spf13/cobra/cobra\n")),t("p",null,"This will download the latest code from github to the directory ",t("inlineCode",{parentName:"p"},"$GOPATH/src/github.com/spf13/cobra"),"\n(GOPATH defaults to\n$HOME/go if you haven't set it). It will also compile cobra into its binary and save that at ",t("inlineCode",{parentName:"p"},"$GOPATH/bin")),t("h4",null,"Install Vipslib"),t("p",null,t("a",{href:"https://jcupitt.github.io/libvips/",parentName:"p"},"Vipslib")," is an image processing library that we'll be using to resize our Hero icons. See ",t("a",{href:"https://jcupitt.github.io/libvips/install.html",parentName:"p"},"Install\nvipslib")," for how to install for your operating system. We'll also need to run:"),t("pre",null,t("code",{className:"language-go",parentName:"pre"},"go get github.com/DAddYE/vips\n")),t("p",null,"to install the Go bindings for Vipslib"),t("h4",null,"Creating the project"),t("p",null,"Start by creating a folder Hero and CD into it. Assuming you have $GOPATH/bin on your $PATH, run:"),t("pre",null,t("code",{className:"language-go",parentName:"pre"},"cobra init\n")),t("p",null,"This will create a LICENSE, a directory cmd containing a single file root.go and your main.go."),t("p",null,"main.go contains package main and function main (which is the starting point for every Go\napplication), and the import of the generated command. The function main delegates to cmd.Execute &\nthat's all we'll need to do in main."),t("pre",null,t("code",{className:"language-go",parentName:"pre"},'// main.go\npackage main\n\nimport "github.com/sinnott74/TestCmd/cmd"\n\nfunc main() {\n    cmd.Execute()\n}\n')),t("p",null,"The generated cmd/root.go will contain a lot more code but for this simple tool we can remove most\nof it. After trimming the fat we're left with:"),t("pre",null,t("code",{className:"language-go",parentName:"pre"},'// cmd/root.go\npackage cmd\n\nimport (\n    "fmt"\n    "os"\n\n    "github.com/spf13/cobra"\n)\n\n// rootCmd represents the base command when called without any subcommands\nvar rootCmd = &cobra.Command{\n    Use:   "Hero image creating utility",\n    Short: "Hero creates banner images quickly",\n    RunE: func(cmd *cobra.Command, args []string) error {\n        return nil\n    },\n}\n\n// Execute adds all child commands to the root command and sets flags appropriately.\n// This is called by main.main(). It only needs to happen once to the rootCmd.\nfunc Execute() {\n    if err := rootCmd.Execute(); err != nil {\n        fmt.Println(err)\n        os.Exit(1)\n    }\n}\n\nfunc init() {\n}\n')),t("h3",null,"Creating our Hero Utility"),t("h4",null,"Adding command line arguments"),t("p",null,"Like all good command line utilities we're going to need to take in some arguments. Our init\nfunction in cmd/root.go is the perfect place for this kind of set up work. init() is called when the\npackage is first imported. Add the following:"),t("pre",null,t("code",{className:"language-go",parentName:"pre"},'var (\n    out      string\n    bgColor  string\n    icons    []string\n    height   int\n    width    int\n    iconsize int\n)\n\nfunc init() {\n    rootCmd.PersistentFlags().StringVarP(&out, "output", "o", "./hero.png", "File to output")\n    rootCmd.PersistentFlags().StringVarP(&bgColor, "color", "c", "red", "Background color")\n    rootCmd.PersistentFlags().StringArrayVarP(&icons, "icons", "i", []string{}, "Icons")\n    rootCmd.PersistentFlags().IntVarP(&width, "width", "x", 960, "Max x coordinate of the hero - width of the hero")\n    rootCmd.PersistentFlags().IntVarP(&height, "height", "y", 480, "Max y coordinate of the hero - height of the hero")\n    rootCmd.PersistentFlags().IntVarP(&iconsize, "iconsize", "s", 300, "Width and height of the incons on the hero")\n}\n')),t("p",null,"This sets up all the arguments we'll need for now. We can now run the application and verify that\nall the arguments are there:"),t("pre",null,t("code",{className:"language-go",parentName:"pre"},'$go run main.go -h\n\nHero creates banner images quickly\n\nUsage:\n  Hero image creating utility [flags]\n\nFlags:\n  -c, --color string        Background color (default "red")\n  -y, --height int          Max y coordinate of the hero - height of the hero (default 480)\n  -h, --help                help for Hero\n  -i, --icons stringArray   Icons\n  -s, --iconsize int        Width and height of the incons on the hero (default 300)\n  -o, --output string       File to output (default "./hero.png")\n  -x, --width int           Max x coordinate of the hero - width of the hero (default 960)\n')),t("p",null,t("inlineCode",{parentName:"p"},"go run")," compiles and runs a go application. Adding the -h flag to any go application that accepts\narguments will show the help blurb."),t("h4",null,"Creating the image"),t("p",null,"To create an image in go we'll need to import the ",t("inlineCode",{parentName:"p"},"image")," package. Update our rootCmd's RunE\nfunction in cmd.go to the following."),t("pre",null,t("code",{className:"language-go",parentName:"pre"},"RunE: func(cmd *cobra.Command, args []string) error {\n\n    // Create the picture\n    pic := image.NewRGBA(image.Rect(0, 0, width, height))\n\n    // Create the file\n    outFile, err := os.Create(out)\n    if err != nil {\n        return err\n    }\n\n    // Write & encode the file\n    err = png.Encode(outFile, pic)\n    if err != nil {\n        return err\n    }\n    return nil\n},\n")),t("p",null,"We're now creating a new picture with the dimensions the user specifies with the command line\narguments. We then create a file and write/encode the picture to disk. Running:"),t("pre",null,t("code",{className:"language-go",parentName:"pre"},"go main.go\n")),t("p",null,"will by default create an tiny blank file ",t("inlineCode",{parentName:"p"},"hero.png"),". We haven't specified the color of any pixel\nyet, which for an RGBA image is R:0 G:0 B:0 A:0 - an invisible black pixel."),t("h4",null,"Setting the color"),t("p",null,"For our colors, we're going to stick to the ",t("a",{href:"https://material.io/design/color/the-color-system.html',",parentName:"p"},"material design color palette"),". Add the following\nsnippet to the file to set up our color"),t("pre",null,t("code",{className:"language-go",parentName:"pre"},'// Material Design colors\nvar (\n    Red400        = color.RGBA{0xef, 0x53, 0x50, 0xff} // rgb(239, 83, 80)\n    Red500        = color.RGBA{0xf4, 0x43, 0x36, 0xff} // rgb(244, 67, 54)\n    Red600        = color.RGBA{0xe5, 0x39, 0x35, 0xff} // rgb(229, 57, 53)\n    Pink400       = color.RGBA{0xec, 0x40, 0x7a, 0xff} // rgb(236, 64, 122)\n    Pink500       = color.RGBA{0xe9, 0x1e, 0x63, 0xff} // rgb(233, 30, 99)\n    Pink600       = color.RGBA{0xd8, 0x1b, 0x60, 0xff} // rgb(216, 27, 96)\n    Purple400     = color.RGBA{0xab, 0x47, 0xbc, 0xff} // rgb(171, 71, 188)\n    Purple500     = color.RGBA{0x9c, 0x27, 0xb0, 0xff} // rgb(156, 39, 176)\n    Purple600     = color.RGBA{0x8e, 0x24, 0xaa, 0xff} // rgb(142, 36, 170)\n    DeepPurple400 = color.RGBA{0x7e, 0x57, 0xc2, 0xff} // rgb(126, 87, 194)\n    DeepPurple500 = color.RGBA{0x67, 0x3a, 0xb7, 0xff} // rgb(103, 58, 183)\n    DeepPurple600 = color.RGBA{0x5e, 0x35, 0xb1, 0xff} // rgb(94, 53, 177)\n    Indigo400     = color.RGBA{0x5c, 0x6b, 0xc0, 0xff} // rgb(92, 107, 192)\n    Indigo500     = color.RGBA{0x3f, 0x51, 0xb5, 0xff} // rgb(63, 81, 181)\n    Indigo600     = color.RGBA{0x39, 0x49, 0xab, 0xff} // rgb(57, 73, 171)\n    Blue400       = color.RGBA{0x42, 0xa5, 0xf5, 0xff} // rgb(66, 165, 245)\n    Blue500       = color.RGBA{0x21, 0x96, 0xf3, 0xff} // rgb(33, 150, 243)\n    Blue600       = color.RGBA{0x1e, 0x88, 0xe5, 0xff} // rgb(30, 136, 229)\n    LightBlue400  = color.RGBA{0x29, 0xb6, 0xf6, 0xff} // rgb(41, 182, 246)\n    LightBlue500  = color.RGBA{0x03, 0xa9, 0xf4, 0xff} // rgb(3, 169, 244)\n    LightBlue600  = color.RGBA{0x03, 0x9b, 0xe5, 0xff} // rgb(3, 155, 229)\n    Cyan400       = color.RGBA{0x26, 0xc6, 0xda, 0xff} // rgb(38, 198, 218)\n    Cyan500       = color.RGBA{0x00, 0xbc, 0xd4, 0xff} // rgb(0, 188, 212)\n    Cyan600       = color.RGBA{0x00, 0xac, 0xc1, 0xff} // rgb(0, 172, 193)\n    Teal400       = color.RGBA{0x26, 0xa6, 0x9a, 0xff} // rgb(38, 166, 154)\n    Teal500       = color.RGBA{0x00, 0x96, 0x88, 0xff} // rgb(0, 150, 136)\n    Teal600       = color.RGBA{0x00, 0x89, 0x7b, 0xff} // rgb(0, 137, 123)\n    Green400      = color.RGBA{0x66, 0xbb, 0x6a, 0xff} // rgb(102, 187, 106)\n    Green500      = color.RGBA{0x4c, 0xaf, 0x50, 0xff} // rgb(76, 175, 80)\n    Green600      = color.RGBA{0x43, 0xa0, 0x47, 0xff} // rgb(67, 160, 71)\n    LightGreen400 = color.RGBA{0x9c, 0xcc, 0x65, 0xff} // rgb(156, 204, 101)\n    LightGreen500 = color.RGBA{0x8b, 0xc3, 0x4a, 0xff} // rgb(139, 195, 74)\n    LightGreen600 = color.RGBA{0x7c, 0xb3, 0x42, 0xff} // rgb(124, 179, 66)\n    Lime400       = color.RGBA{0xd4, 0xe1, 0x57, 0xff} // rgb(212, 225, 87)\n    Lime500       = color.RGBA{0xcd, 0xdc, 0x39, 0xff} // rgb(205, 220, 57)\n    Lime600       = color.RGBA{0xc0, 0xca, 0x33, 0xff} // rgb(192, 202, 51)\n    Yellow500     = color.RGBA{0xff, 0xeb, 0x3b, 0xff} // rgb(255, 235, 59)\n    Yellow600     = color.RGBA{0xfd, 0xd8, 0x35, 0xff} // rgb(253, 216, 53)\n    Yellow700     = color.RGBA{0xfb, 0xc0, 0x2d, 0xff} // rgb(251, 192, 45)\n    Amber400      = color.RGBA{0xff, 0xca, 0x28, 0xff} // rgb(255, 202, 40)\n    Amber500      = color.RGBA{0xff, 0xc1, 0x07, 0xff} // rgb(255, 193, 7)\n    Amber600      = color.RGBA{0xff, 0xb3, 0x00, 0xff} // rgb(255, 179, 0)\n    Orange400     = color.RGBA{0xff, 0xa7, 0x26, 0xff} // rgb(255, 167, 38)\n    Orange500     = color.RGBA{0xff, 0x98, 0x00, 0xff} // rgb(255, 152, 0)\n    Orange600     = color.RGBA{0xfb, 0x8c, 0x00, 0xff} // rgb(251, 140, 0)\n    DeepOrange400 = color.RGBA{0xff, 0x70, 0x43, 0xff} // rgb(255, 112, 67)\n    DeepOrange500 = color.RGBA{0xff, 0x57, 0x22, 0xff} // rgb(255, 87, 34)\n    DeepOrange600 = color.RGBA{0xf4, 0x51, 0x1e, 0xff} // rgb(244, 81, 30)\n    Brown400      = color.RGBA{0x8d, 0x6e, 0x63, 0xff} // rgb(141, 110, 99)\n    Brown500      = color.RGBA{0x79, 0x55, 0x48, 0xff} // rgb(121, 85, 72)\n    Brown600      = color.RGBA{0x6d, 0x4c, 0x41, 0xff} // rgb(109, 76, 65)\n    Grey400       = color.RGBA{0xbd, 0xbd, 0xbd, 0xff} // rgb(189, 189, 189)\n    Grey500       = color.RGBA{0x9e, 0x9e, 0x9e, 0xff} // rgb(158, 158, 158)\n    Grey600       = color.RGBA{0x75, 0x75, 0x75, 0xff} // rgb(117, 117, 117)\n    BlueGrey400   = color.RGBA{0x78, 0x90, 0x9c, 0xff} // rgb(120, 144, 156)\n    BlueGrey500   = color.RGBA{0x60, 0x7d, 0x8b, 0xff} // rgb(96, 125, 139)\n    BlueGrey600   = color.RGBA{0x54, 0x6e, 0x7a, 0xff} // rgb(84, 110, 122)\n)\n\n// Map of Color Names to color\nvar Map = make(map[string][3]color.RGBA)\n\n// Multiple init funcs are allowed\nfunc init() {\n    Map["red"] = [3]color.RGBA{Red400, Red500, Red600}\n    Map["pink"] = [3]color.RGBA{Pink400, Pink500, Pink600}\n    Map["purple"] = [3]color.RGBA{Purple400, Purple500, Purple600}\n    Map["deeppurple"] = [3]color.RGBA{DeepPurple400, DeepPurple500, DeepPurple600}\n    Map["indigo"] = [3]color.RGBA{Indigo400, Indigo500, Indigo600}\n    Map["blue"] = [3]color.RGBA{Blue400, Blue500, Blue600}\n    Map["lightblue"] = [3]color.RGBA{LightBlue400, LightBlue500, LightBlue600}\n    Map["cyan"] = [3]color.RGBA{Cyan400, Cyan500, Cyan600}\n    Map["teal"] = [3]color.RGBA{Teal400, Teal500, Teal600}\n    Map["green"] = [3]color.RGBA{Green400, Green500, Green600}\n    Map["lime"] = [3]color.RGBA{Lime400, Lime500, Lime600}\n    Map["yellow"] = [3]color.RGBA{Yellow500, Yellow600, Yellow700}\n    Map["amber"] = [3]color.RGBA{Amber400, Amber500, Amber600}\n    Map["orange"] = [3]color.RGBA{Orange400, Orange500, Orange600}\n    Map["deeporange"] = [3]color.RGBA{DeepOrange400, DeepOrange500, DeepOrange600}\n    Map["brown"] = [3]color.RGBA{Brown400, Brown500, Brown600}\n    Map["grey"] = [3]color.RGBA{Grey400, Grey500, Grey600}\n    Map["bluegrey"] = [3]color.RGBA{BlueGrey400, BlueGrey500, BlueGrey600}\n}\n\n// getColor gets a RGBA color\nfunc getColor(colorName *string) ([3]color.RGBA, error) {\n    colors, ok := Map[*colorName]\n    if !ok {\n        return [3]color.RGBA{}, fmt.Errorf("Color %s could not be found", *colorName)\n    }\n    return colors, nil\n}\n')),t("p",null,"You may have noticed from the Hero on this blogpost that our background has three sections, divided\nby two diagonal lines, increasing in darkness from left to right. To do this we need to loop through\nevery pixel in the Hero and set the color based on which section it is in."),t("p",null,"We define a new type represent out diagonal lines - line. It consists of two points. Based on where\neach pixel is relative to the diagonal lines, we can set its color."),t("pre",null,t("code",{className:"language-go",parentName:"pre"},"type line struct {\n    p1 image.Point\n    p2 image.Point\n}\n\n// setImageColor sets the background color of an image\nfunc setImageColor(pic *image.RGBA, bgColor *string) error {\n\n    width := pic.Bounds().Max.X\n    height := pic.Bounds().Max.Y\n\n    leftLine := line{image.Point{width / 4, 0}, image.Point{width / 20, height}}\n    rightLine := line{image.Point{width, height - 2*height/3}, image.Point{width - width/3, height}}\n\n    colors, err := getColor(bgColor)\n    if err != nil {\n        return err\n    }\n\n    leftColor := colors[0]\n    middleColor := colors[1]\n    rightColor := colors[2]\n\n    // Update the colour of each pixel\n    for x := pic.Bounds().Min.X; x < pic.Bounds().Max.X; x++ {\n        for y := pic.Bounds().Min.Y; y < pic.Bounds().Max.Y; y++ {\n\n            p := image.Point{x, y}\n            if isLeftOfLine(leftLine, p) {\n                pic.Set(x, y, leftColor)\n            } else if isRightOfLine(rightLine, p) {\n                pic.Set(x, y, rightColor)\n            } else {\n                pic.Set(x, y, middleColor)\n            }\n        }\n    }\n    return nil\n}\n\n// isRightOfLine checks if a point is to the right of the line\nfunc isRightOfLine(l line, p image.Point) bool {\n    return !isLeftOfLine(l, p)\n}\n\n// isLeftOfLine checks if a point is to the left of the line\nfunc isLeftOfLine(l line, p image.Point) bool {\n    d := (p.X-l.p1.X)*(l.p2.Y-l.p1.Y) - (p.Y-l.p1.Y)*(l.p2.X-l.p1.X)\n    return d < 0\n}\n")),t("p",null,"We can now call our setImageColor function before we encode the png, without forgetting to check for\nerrors."),t("pre",null,t("code",{className:"language-go",parentName:"pre"},"err = setImageColor(pic, &bgColor)\nif err != nil {\n    return err\n}\n")),t("p",null,"Now when we run"),t("pre",null,t("code",{className:"language-go",parentName:"pre"},"go run main.go\n")),t("p",null,"We'll get a hero.png file with dimensions 960*480 by default, with red background containing our\npattern."),t("p",null,t("img",{src:"https://i.imgur.com/yDqToGj.png",alt:"Red hero",title:"Red hero",parentName:"p"})),t("h3",null,"Adding icons"),t("p",null,"To add our icons, we'll need to:"),t("ul",null,t("li",{parentName:"ul"},"Read them into memory"),t("li",{parentName:"ul"},"Resize them"),t("li",{parentName:"ul"},"Determine their position in the Hero"),t("li",{parentName:"ul"},"Finally, add them to the Hero")),t("p",null,"This can be accomplished with the following code:"),t("pre",null,t("code",{className:"language-go",parentName:"pre"},"// addIcons add icons to the pic\nfunc addIcons(pic *image.RGBA, iconPaths []string, iconSize image.Point) error {\n\n    width := pic.Bounds().Max.X\n    height := pic.Bounds().Max.Y\n\n    numIcons := len(iconPaths)\n    horizonalPaddingNum := numIcons + 1\n    paddingWidth := (width - iconSize.Y*numIcons) / horizonalPaddingNum\n\n    for i, iconPath := range iconPaths {\n        icon, err := readIcon(&iconPath)\n        if err != nil {\n            return err\n        }\n        resizedIcon, err := resizeIcon(&icon, iconSize)\n        if err != nil {\n            return err\n        }\n\n        diff := iconSize.Sub(resizedIcon.Bounds().Max).Div(2)\n        offset := image.Pt(paddingWidth+iconSize.X*i+paddingWidth*i, height/2-iconSize.Y/2).Add(diff)\n        addIconToPic(pic, resizedIcon, offset)\n    }\n    return nil\n}\n\n// readIcon reads in the btyes of a given file\nfunc readIcon(iconPath *string) ([]byte, error) {\n\n    inBuf, err := ioutil.ReadFile(*iconPath)\n    if err != nil {\n        return nil, err\n    }\n    return inBuf, nil\n}\n\n// resizeIcon resizes the file\nfunc resizeIcon(icon *[]byte, iconSize image.Point) (image.Image, error) {\n    options := vips.Options{\n        Width:        iconSize.X,\n        Height:       iconSize.Y,\n        Crop:         false,\n        Extend:       vips.EXTEND_WHITE,\n        Interpolator: vips.BILINEAR,\n        Gravity:      vips.CENTRE,\n        Quality:      100,\n        Format:       vips.PNG,\n    }\n\n    buf, err := vips.Resize(*icon, options)\n    if err != nil {\n        return nil, err\n    }\n\n    resizedIcon, _, err := image.Decode(bytes.NewReader(buf))\n    if err != nil {\n        return nil, err\n    }\n\n    return resizedIcon, nil\n}\n\n// addIconToPic adds the icon to the picture\nfunc addIconToPic(pic draw.Image, icon image.Image, offset image.Point) {\n    draw.Draw(pic, icon.Bounds().Add(offset), icon, image.ZP, draw.Over)\n}\n")),t("p",null,"Add a call to addIcons after setImageColor in out rootCmd"),t("pre",null,t("code",{className:"language-go",parentName:"pre"},"err = addIcons(pic, icons, image.Point{iconsize, iconsize})\nif err != nil {\n    return err\n}\n")),t("h4",null,"Our Hero"),t("p",null,"Finally run"),t("pre",null,t("code",{className:"language-go",parentName:"pre"},"go run main.go -i hero_icon.png -i gopher.png -c blue\n")),t("p",null,"where hero_icon.png and gopher.png are images on your system, will create our ",t("strong",{parentName:"p"},"HERO!")),t("p",null,t("img",{src:"https://i.imgur.com/ZVaDnJx.png",alt:"Hero",title:"Hero",parentName:"p"})),t("h4",null,"The full source of root.go can be seen below"),t("pre",null,t("code",{className:"language-go",parentName:"pre"},'package cmd\n\nimport (\n    "bytes"\n    "fmt"\n    "image"\n    "image/color"\n    "image/draw"\n    "image/png"\n    "io/ioutil"\n    "os"\n\n    "github.com/DAddYE/vips"\n    "github.com/spf13/cobra"\n)\n\n// Command line arguments\nvar (\n    out      string\n    bgColor  string\n    icons    []string\n    height   int\n    width    int\n    iconsize int\n)\n\n// Material Design colors\nvar (\n    Red400        = color.RGBA{0xef, 0x53, 0x50, 0xff} // rgb(239, 83, 80)\n    Red500        = color.RGBA{0xf4, 0x43, 0x36, 0xff} // rgb(244, 67, 54)\n    Red600        = color.RGBA{0xe5, 0x39, 0x35, 0xff} // rgb(229, 57, 53)\n    Pink400       = color.RGBA{0xec, 0x40, 0x7a, 0xff} // rgb(236, 64, 122)\n    Pink500       = color.RGBA{0xe9, 0x1e, 0x63, 0xff} // rgb(233, 30, 99)\n    Pink600       = color.RGBA{0xd8, 0x1b, 0x60, 0xff} // rgb(216, 27, 96)\n    Purple400     = color.RGBA{0xab, 0x47, 0xbc, 0xff} // rgb(171, 71, 188)\n    Purple500     = color.RGBA{0x9c, 0x27, 0xb0, 0xff} // rgb(156, 39, 176)\n    Purple600     = color.RGBA{0x8e, 0x24, 0xaa, 0xff} // rgb(142, 36, 170)\n    DeepPurple400 = color.RGBA{0x7e, 0x57, 0xc2, 0xff} // rgb(126, 87, 194)\n    DeepPurple500 = color.RGBA{0x67, 0x3a, 0xb7, 0xff} // rgb(103, 58, 183)\n    DeepPurple600 = color.RGBA{0x5e, 0x35, 0xb1, 0xff} // rgb(94, 53, 177)\n    Indigo400     = color.RGBA{0x5c, 0x6b, 0xc0, 0xff} // rgb(92, 107, 192)\n    Indigo500     = color.RGBA{0x3f, 0x51, 0xb5, 0xff} // rgb(63, 81, 181)\n    Indigo600     = color.RGBA{0x39, 0x49, 0xab, 0xff} // rgb(57, 73, 171)\n    Blue400       = color.RGBA{0x42, 0xa5, 0xf5, 0xff} // rgb(66, 165, 245)\n    Blue500       = color.RGBA{0x21, 0x96, 0xf3, 0xff} // rgb(33, 150, 243)\n    Blue600       = color.RGBA{0x1e, 0x88, 0xe5, 0xff} // rgb(30, 136, 229)\n    LightBlue400  = color.RGBA{0x29, 0xb6, 0xf6, 0xff} // rgb(41, 182, 246)\n    LightBlue500  = color.RGBA{0x03, 0xa9, 0xf4, 0xff} // rgb(3, 169, 244)\n    LightBlue600  = color.RGBA{0x03, 0x9b, 0xe5, 0xff} // rgb(3, 155, 229)\n    Cyan400       = color.RGBA{0x26, 0xc6, 0xda, 0xff} // rgb(38, 198, 218)\n    Cyan500       = color.RGBA{0x00, 0xbc, 0xd4, 0xff} // rgb(0, 188, 212)\n    Cyan600       = color.RGBA{0x00, 0xac, 0xc1, 0xff} // rgb(0, 172, 193)\n    Teal400       = color.RGBA{0x26, 0xa6, 0x9a, 0xff} // rgb(38, 166, 154)\n    Teal500       = color.RGBA{0x00, 0x96, 0x88, 0xff} // rgb(0, 150, 136)\n    Teal600       = color.RGBA{0x00, 0x89, 0x7b, 0xff} // rgb(0, 137, 123)\n    Green400      = color.RGBA{0x66, 0xbb, 0x6a, 0xff} // rgb(102, 187, 106)\n    Green500      = color.RGBA{0x4c, 0xaf, 0x50, 0xff} // rgb(76, 175, 80)\n    Green600      = color.RGBA{0x43, 0xa0, 0x47, 0xff} // rgb(67, 160, 71)\n    LightGreen400 = color.RGBA{0x9c, 0xcc, 0x65, 0xff} // rgb(156, 204, 101)\n    LightGreen500 = color.RGBA{0x8b, 0xc3, 0x4a, 0xff} // rgb(139, 195, 74)\n    LightGreen600 = color.RGBA{0x7c, 0xb3, 0x42, 0xff} // rgb(124, 179, 66)\n    Lime400       = color.RGBA{0xd4, 0xe1, 0x57, 0xff} // rgb(212, 225, 87)\n    Lime500       = color.RGBA{0xcd, 0xdc, 0x39, 0xff} // rgb(205, 220, 57)\n    Lime600       = color.RGBA{0xc0, 0xca, 0x33, 0xff} // rgb(192, 202, 51)\n    Yellow500     = color.RGBA{0xff, 0xeb, 0x3b, 0xff} // rgb(255, 235, 59)\n    Yellow600     = color.RGBA{0xfd, 0xd8, 0x35, 0xff} // rgb(253, 216, 53)\n    Yellow700     = color.RGBA{0xfb, 0xc0, 0x2d, 0xff} // rgb(251, 192, 45)\n    Amber400      = color.RGBA{0xff, 0xca, 0x28, 0xff} // rgb(255, 202, 40)\n    Amber500      = color.RGBA{0xff, 0xc1, 0x07, 0xff} // rgb(255, 193, 7)\n    Amber600      = color.RGBA{0xff, 0xb3, 0x00, 0xff} // rgb(255, 179, 0)\n    Orange400     = color.RGBA{0xff, 0xa7, 0x26, 0xff} // rgb(255, 167, 38)\n    Orange500     = color.RGBA{0xff, 0x98, 0x00, 0xff} // rgb(255, 152, 0)\n    Orange600     = color.RGBA{0xfb, 0x8c, 0x00, 0xff} // rgb(251, 140, 0)\n    DeepOrange400 = color.RGBA{0xff, 0x70, 0x43, 0xff} // rgb(255, 112, 67)\n    DeepOrange500 = color.RGBA{0xff, 0x57, 0x22, 0xff} // rgb(255, 87, 34)\n    DeepOrange600 = color.RGBA{0xf4, 0x51, 0x1e, 0xff} // rgb(244, 81, 30)\n    Brown400      = color.RGBA{0x8d, 0x6e, 0x63, 0xff} // rgb(141, 110, 99)\n    Brown500      = color.RGBA{0x79, 0x55, 0x48, 0xff} // rgb(121, 85, 72)\n    Brown600      = color.RGBA{0x6d, 0x4c, 0x41, 0xff} // rgb(109, 76, 65)\n    Grey400       = color.RGBA{0xbd, 0xbd, 0xbd, 0xff} // rgb(189, 189, 189)\n    Grey500       = color.RGBA{0x9e, 0x9e, 0x9e, 0xff} // rgb(158, 158, 158)\n    Grey600       = color.RGBA{0x75, 0x75, 0x75, 0xff} // rgb(117, 117, 117)\n    BlueGrey400   = color.RGBA{0x78, 0x90, 0x9c, 0xff} // rgb(120, 144, 156)\n    BlueGrey500   = color.RGBA{0x60, 0x7d, 0x8b, 0xff} // rgb(96, 125, 139)\n    BlueGrey600   = color.RGBA{0x54, 0x6e, 0x7a, 0xff} // rgb(84, 110, 122)\n)\n\n// Map of Color Names to color\nvar Map = make(map[string][3]color.RGBA)\n\n// Multiple init funcs are allowed\nfunc init() {\n    Map["red"] = [3]color.RGBA{Red400, Red500, Red600}\n    Map["pink"] = [3]color.RGBA{Pink400, Pink500, Pink600}\n    Map["purple"] = [3]color.RGBA{Purple400, Purple500, Purple600}\n    Map["deeppurple"] = [3]color.RGBA{DeepPurple400, DeepPurple500, DeepPurple600}\n    Map["indigo"] = [3]color.RGBA{Indigo400, Indigo500, Indigo600}\n    Map["blue"] = [3]color.RGBA{Blue400, Blue500, Blue600}\n    Map["lightblue"] = [3]color.RGBA{LightBlue400, LightBlue500, LightBlue600}\n    Map["cyan"] = [3]color.RGBA{Cyan400, Cyan500, Cyan600}\n    Map["teal"] = [3]color.RGBA{Teal400, Teal500, Teal600}\n    Map["green"] = [3]color.RGBA{Green400, Green500, Green600}\n    Map["lime"] = [3]color.RGBA{Lime400, Lime500, Lime600}\n    Map["yellow"] = [3]color.RGBA{Yellow500, Yellow600, Yellow700}\n    Map["amber"] = [3]color.RGBA{Amber400, Amber500, Amber600}\n    Map["orange"] = [3]color.RGBA{Orange400, Orange500, Orange600}\n    Map["deeporange"] = [3]color.RGBA{DeepOrange400, DeepOrange500, DeepOrange600}\n    Map["brown"] = [3]color.RGBA{Brown400, Brown500, Brown600}\n    Map["grey"] = [3]color.RGBA{Grey400, Grey500, Grey600}\n    Map["bluegrey"] = [3]color.RGBA{BlueGrey400, BlueGrey500, BlueGrey600}\n}\n\n// rootCmd represents the base command when called without any subcommands\nvar rootCmd = &cobra.Command{\n    Use:   "Hero image creating utility",\n    Short: "Hero creates banner images quickly",\n    RunE: func(cmd *cobra.Command, args []string) error {\n\n        // Create the picture\n        pic := image.NewRGBA(image.Rect(0, 0, width, height))\n\n        // Create the file\n        outFile, err := os.Create(out)\n        if err != nil {\n            return err\n        }\n\n        err = setImageColor(pic, &bgColor)\n        if err != nil {\n            return err\n        }\n\n        err = addIcons(pic, icons, image.Point{iconsize, iconsize})\n        if err != nil {\n            return err\n        }\n\n        // Encode & Write the file\n        err = png.Encode(outFile, pic)\n        if err != nil {\n            return err\n        }\n        return nil\n    },\n}\n\n// Execute adds all child commands to the root command and sets flags appropriately.\n// This is called by main.main(). It only needs to happen once to the rootCmd.\nfunc Execute() {\n    if err := rootCmd.Execute(); err != nil {\n        fmt.Println(err)\n        os.Exit(1)\n    }\n}\n\nfunc init() {\n    rootCmd.PersistentFlags().StringVarP(&out, "output", "o", "./hero.png", "File to output")\n    rootCmd.PersistentFlags().StringVarP(&bgColor, "color", "c", "red", "Background color")\n    rootCmd.PersistentFlags().StringArrayVarP(&icons, "icons", "i", []string{}, "Icons")\n    rootCmd.PersistentFlags().IntVarP(&width, "width", "x", 960, "Max x coordinate of the hero - width of the hero")\n    rootCmd.PersistentFlags().IntVarP(&height, "height", "y", 480, "Max y coordinate of the hero - height of the hero")\n    rootCmd.PersistentFlags().IntVarP(&iconsize, "iconsize", "s", 300, "Width and height of the incons on the hero")\n}\n\ntype line struct {\n    p1 image.Point\n    p2 image.Point\n}\n\n// setImageColor sets the background color of an image\nfunc setImageColor(pic *image.RGBA, bgColor *string) error {\n\n    width := pic.Bounds().Max.X\n    height := pic.Bounds().Max.Y\n\n    leftLine := line{image.Point{width / 4, 0}, image.Point{width / 20, height}}\n    rightLine := line{image.Point{width, height - 2*height/3}, image.Point{width - width/3, height}}\n\n    colors, err := getColor(bgColor)\n    if err != nil {\n        return err\n    }\n\n    leftColor := colors[0]\n    middleColor := colors[1]\n    rightColor := colors[2]\n\n    // Update the colour of each pixel\n    for x := pic.Bounds().Min.X; x < pic.Bounds().Max.X; x++ {\n        for y := pic.Bounds().Min.Y; y < pic.Bounds().Max.Y; y++ {\n\n            p := image.Point{x, y}\n            if isLeftOfLine(leftLine, p) {\n                pic.Set(x, y, leftColor)\n            } else if isRightOfLine(rightLine, p) {\n                pic.Set(x, y, rightColor)\n            } else {\n                pic.Set(x, y, middleColor)\n            }\n        }\n    }\n    return nil\n}\n\n// getColor gets a RGBA color\nfunc getColor(colorName *string) ([3]color.RGBA, error) {\n    colors, ok := Map[*colorName]\n    if !ok {\n        return [3]color.RGBA{}, fmt.Errorf("Color %s could not be found", *colorName)\n    }\n    return colors, nil\n}\n\n// isRightOfLine checks if a point is to the right of the line\nfunc isRightOfLine(l line, p image.Point) bool {\n    return !isLeftOfLine(l, p)\n}\n\n// isLeftOfLine checks if a point is to the left of the line\nfunc isLeftOfLine(l line, p image.Point) bool {\n    d := (p.X-l.p1.X)*(l.p2.Y-l.p1.Y) - (p.Y-l.p1.Y)*(l.p2.X-l.p1.X)\n    return d < 0\n}\n\n// addIcons add icons to the pic\nfunc addIcons(pic *image.RGBA, iconPaths []string, iconSize image.Point) error {\n\n    width := pic.Bounds().Max.X\n    height := pic.Bounds().Max.Y\n\n    numIcons := len(iconPaths)\n    horizonalPaddingNum := numIcons + 1\n    paddingWidth := (width - iconSize.Y*numIcons) / horizonalPaddingNum\n\n    for i, iconPath := range iconPaths {\n        icon, err := readIcon(&iconPath)\n        if err != nil {\n            return err\n        }\n        resizedIcon, err := resizeIcon(&icon, iconSize)\n        if err != nil {\n            return err\n        }\n\n        diff := iconSize.Sub(resizedIcon.Bounds().Max).Div(2)\n        offset := image.Pt(paddingWidth+iconSize.X*i+paddingWidth*i, height/2-iconSize.Y/2).Add(diff)\n        addIconToPic(pic, resizedIcon, offset)\n    }\n    return nil\n}\n\n// readIcon reads in the btyes of a given file\nfunc readIcon(iconPath *string) ([]byte, error) {\n\n    inBuf, err := ioutil.ReadFile(*iconPath)\n    if err != nil {\n        return nil, err\n    }\n    return inBuf, nil\n}\n\n// resizeIcon resizes the file\nfunc resizeIcon(icon *[]byte, iconSize image.Point) (image.Image, error) {\n    options := vips.Options{\n        Width:        iconSize.X,\n        Height:       iconSize.Y,\n        Crop:         false,\n        Extend:       vips.EXTEND_WHITE,\n        Interpolator: vips.BILINEAR,\n        Gravity:      vips.CENTRE,\n        Quality:      100,\n        Format:       vips.PNG,\n    }\n\n    buf, err := vips.Resize(*icon, options)\n    if err != nil {\n        return nil, err\n    }\n\n    resizedIcon, _, err := image.Decode(bytes.NewReader(buf))\n    if err != nil {\n        return nil, err\n    }\n\n    return resizedIcon, nil\n}\n\n// addIconToPic adds the icon to the picture\nfunc addIconToPic(pic draw.Image, icon image.Image, offset image.Point) {\n    draw.Draw(pic, icon.Bounds().Add(offset), icon, image.ZP, draw.Over)\n}\n\n')))}p.isMDXComponent=!0;export default p;export{a as author,x as created,s as date,g as id,c as imageurl,f as tags,l as title};
