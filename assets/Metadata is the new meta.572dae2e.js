var e=Object.defineProperty,t=Object.getOwnPropertySymbols,a=Object.prototype.hasOwnProperty,r=Object.prototype.propertyIsEnumerable,o=(t,a,r)=>a in t?e(t,a,{enumerable:!0,configurable:!0,writable:!0,value:r}):t[a]=r;import"./vendor.f315bbe5.js";import{N as n}from"./mdx-react.modern.e61303d7.js";const l="Metadata is the new meta",s="Daniel Sinnott",i="https://i.imgur.com/UNJ8ecB.png",c=17,p=["Technical","Decorators","Typescript"],u="Tue, 24th Apr 2018",m=new Date(1524575314299);function d(e){var l=e,{components:s}=l,i=((e,o)=>{var n={};for(var l in e)a.call(e,l)&&o.indexOf(l)<0&&(n[l]=e[l]);if(null!=e&&t)for(var l of t(e))o.indexOf(l)<0&&r.call(e,l)&&(n[l]=e[l]);return n})(l,["components"]);return n("wrapper",((e,n)=>{for(var l in n||(n={}))a.call(n,l)&&o(e,l,n[l]);if(t)for(var l of t(n))r.call(n,l)&&o(e,l,n[l]);return e})({components:s},i),n("h2",null,"Decorators"),n("p",null,"Decorators are a way to add metadata to parts of your Javascript code. Those familar Java will see\nthem as Javascript's implementation of annotations."),n("p",null,"It's worth noting before we get into it that decorators are overly complicated. ",n("strong",{parentName:"p"},"They're just\nfunctions"),"."),n("p",null,"Decorators are currently a ",n("a",{href:"https://tc39.github.io/proposal-decorators/",parentName:"p"},"TC39 Proposal")," to add annotations to the ECMA/Javascript language.\nLuckily, this proposal has already been implemented in Microsoft Typescript, which is a superset of\nJavascript. However, the following ",n("inlineCode",{parentName:"p"},"compilerOptions")," are needed in your ",n("inlineCode",{parentName:"p"},"tsconfig.json")," to allow you\nto use decorators in typescript."),n("pre",null,n("code",{className:"language-typescript",parentName:"pre"},'{\n    "compilerOptions": {\n        "experimentalDecorators": true\n    }\n}\n\n')),n("p",null,"Javascript lacks a powerful ",n("inlineCode",{parentName:"p"},"Reflection")," like Java, as such decorators work a little differently to\nannotations. They need to be given access to all variables associated with what they are decorating\nas opposed to being able to examine its own behaviour at runtime."),n("p",null,"Decorators come in five flavours:"),n("ul",null,n("li",{parentName:"ul"},"Class decorators"),n("li",{parentName:"ul"},"Method decorators"),n("li",{parentName:"ul"},"Accessor decorators"),n("li",{parentName:"ul"},"Property decorators"),n("li",{parentName:"ul"},"Parameter decorators")),n("p",null,"According to the Typescript documentation there is a well defined order to how decorators are\napplied at runtime:"),n("blockquote",null,n("ol",{parentName:"blockquote"},n("li",{parentName:"ol"},"Parameter Decorators, followed by Method, Accessor, or Property Decorators are applied for each\ninstance member."),n("li",{parentName:"ol"},"Parameter Decorators, followed by Method, Accessor, or Property Decorators are applied for each\nstatic member."),n("li",{parentName:"ol"},"Parameter Decorators are applied for the constructor."),n("li",{parentName:"ol"},"Class Decorators are applied for the class."))),n("h3",null,"Decorator Factories"),n("p",null,"The signature for each of the decorators is defined in the proposal. As such, there isn't much\nflexibility to allow developers to customise the inputs."),n("p",null,"A decorator factory is just a method which returns a decorator. This factory method can take in\nwhatever parameters you'd like as long as it returns the appropriate decorator."),n("h2",null,"Class Decorators"),n("p",null,"Class decorators are applied to an ES2015 class. It's given the class constructor as its only input.\nClass decorators are very powerful, they've the ability to return a different constructor method\nwhich will completely replace the class's own constructor."),n("h4",null,"Signature"),n("pre",null,n("code",{className:"language-typescript",parentName:"pre"},"ClassDecorator = <TFunction extends Function>(target: TFunction) => TFunction;\n")),n("p",null,"where:"),n("ul",null,n("li",{parentName:"ul"},"target = a Constructor function")),n("h4",null,"Example"),n("pre",null,n("code",{className:"language-typescript",parentName:"pre"},'function JoeBloggs<T extends { new (...args: any[]): {} }>(constructor: T) {\n    return class extends constructor {\n      firstname = "Joe";\n      lastname = "Bloggs"\n   }\n\n@JoeBloggs\nclass Me {\n  firstname = "Daniel";\n  lastname = "Sinnott"\n}\n\nconst daniel = new Me();\nconsole.log(daniel.firstname);\nconsole.log(daniel.lastname);\n')),n("p",null,"The above decorator @JoeBloggs takes in a constructor and replaces it with its returned constructor.\nThe names first & last names logged at the end are Joe & Bloggs."),n("h2",null,"Method Decorators"),n("p",null,"Method decorators are applied above a method. It has the ability either modify a method's property\ndescriptor or to return a completely new property descriptor which will be used instead."),n("h4",null,"Signature"),n("pre",null,n("code",{className:"language-typescript",parentName:"pre"},"MethodDecorator = <T>(target: Object, key: string, descriptor: TypedPropertyDescriptor<T>) => TypedPropertyDescriptor<T> | Void;\n")),n("p",null,"Where :"),n("ul",null,n("li",{parentName:"ul"},"target = constructor function of the class for a static method, or the prototype of the class\nfor an instance method."),n("li",{parentName:"ul"},"key = the name of the method"),n("li",{parentName:"ul"},"descriptor = the property descriptor of the method")),n("h4",null,"Example"),n("pre",null,n("code",{className:"language-typescript",parentName:"pre"},'function Enumerable(value: boolean) {\n    return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n        descriptor.enumerable = value;\n    };\n}\n\nclass Me {\n    @Enumerable(false)\n    title() {\n        return "Your Majesty";\n    }\n    @Enumerable(true)\n    firstname() {\n        return "Daniel";\n    }\n    @Enumerable(true)\n    lastname() {\n        return "Sinnott";\n    }\n}\n\nconst Daniel = new Me();\nfor (const prop in Daniel) {\n    console.log(prop);\n}\n')),n("p",null,'which creates a class with 3 methods which are non-enumerable by default, the added decorator\nspecifies that firstname & lastname should be enumerable. The property loop logs "Daniel" &\n"Sinnott"'),n("h2",null,"Accessor Decorators"),n("p",null,"Accessor decorators all almost identical to method decorators. However, they can only be applied to\neither the ",n("inlineCode",{parentName:"p"},"get")," or ",n("inlineCode",{parentName:"p"},"set")," accessor methods, not both."),n("h2",null,"Property Decorators"),n("p",null,"A Property Decorator is declared just before a class property declaration. Its used to observe that\na property has been declared for a class."),n("h4",null,"Signature"),n("pre",null,n("code",{className:"language-typescript",parentName:"pre"},"PropertyDecorator = (target: Object, key: string) => Void;\n")),n("p",null,"Where :"),n("ul",null,n("li",{parentName:"ul"},"target = constructor function of the class for a static method, or the prototype of the class\nfor an instance method."),n("li",{parentName:"ul"},"key = the name of the property")),n("h4",null,"Example"),n("pre",null,n("code",{className:"language-typescript",parentName:"pre"},'function Column(options: {type: string}) {\n    return function(object: Object, propertyName: string): void {\n      // Record database column meta data\n    };\n  }\n\nclass Person {\n  @Column({type: "VARCHAR"})\n  firstname;\n\n  @Column({type: "VARCHAR"})\n  lastname;\n')),n("p",null,"the above example is snippit from my own ORM which is being converted to typescript & decorators to\nallow for a nicer developer experience. It defines a class & records the database metadata for each\nclass property so that it can converted into a database table."),n("h2",null,"Parameter Decorators"),n("p",null,"A Parameter Decorator is declared just before a function parameter declaration. The function can be\na class constructor or a method."),n("p",null,"Parameter decorators are very similar in that they are mainly way of observing that a parameter has\nbeen declared. There isn't a huge amount you can do to the parameter in the decorator. Their power\ncomes from the decorator order. You might remember from above that parameter decorators are\nevaluated first. It then possible to store parameter metadata so that it can then be used in a\nmethod decorator later in the decorator order."),n("h4",null,"Signature"),n("pre",null,n("code",{className:"language-typescript",parentName:"pre"},"ParameterDecorator = (target: Object, key: string, index: number) => Void;\n")),n("p",null,"where:"),n("ul",null,n("li",{parentName:"ul"},"target = constructor function of the class for a static method, or the prototype of the class\nfor an instance method."),n("li",{parentName:"ul"},"key = the name of the method"),n("li",{parentName:"ul"},"index = the index of the parameter in the function's parameter list")),n("h4",null,"Example"),n("pre",null,n("code",{className:"language-typescript",parentName:"pre"},'const LOGPARAMS = "LOGPARAMS";\nfunction LogParameter(object, methodName, index) {\n    if (!object[LOGPARAMS]) {\n        object[LOGPARAMS] = [];\n    }\n    object[LOGPARAMS].push(index);\n}\n\nfunction LogMethod(object, methodName, descriptor) {\n    const originalMethod = descriptor.value;\n    descriptor.value = function (...args) {\n        console.log(`Calling ${object.constructor.name}.${methodName}`);\n        console.log(`with logged params:`);\n        object[LOGPARAMS].reverse().forEach((index) => {\n            const paramValue = args[index];\n            console.log(`${paramValue}`);\n        });\n        return originalMethod.apply(this, args);\n    };\n}\n\nclass Person {\n    fullname: string;\n    @LogMethod\n    setFullname(@LogParameter firstname, middlename, @LogParameter lastname) {\n        this.fullname = `${firstname} ${middlename} ${lastname}`;\n    }\n}\n\nconst me = new Person();\nme.setFullname("Daniel", "Peter", "Sinnott");\nconsole.log(`Fullname is: ${me.fullname}`);\n')),n("p",null,"The above example specifies that it wants to log the method setFullname & the firstname and lastname\nparameters. The LogParameter decorator stores the the index of the params which it whats to log on\nthe actual object."),n("p",null,"Then during the LogMethod decorator we replace the actual setFullname method which our own method\nwhich logs the name of the method & the parameter whose indexes we stored previous, and then finally\ndelegates to the actual setFullname method."),n("p",null,"The example outputs:"),n("blockquote",null,n("p",{parentName:"blockquote"},"Calling Person.setFullname with logged params: Daniel Sinnott Fullname is: Daniel Peter Sinnott")))}d.isMDXComponent=!0;export default d;export{s as author,m as created,u as date,c as id,i as imageurl,p as tags,l as title};
