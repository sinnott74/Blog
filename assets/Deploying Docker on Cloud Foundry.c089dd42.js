var e=Object.defineProperty,n=Object.getOwnPropertySymbols,o=Object.prototype.hasOwnProperty,t=Object.prototype.propertyIsEnumerable,a=(n,o,t)=>o in n?e(n,o,{enumerable:!0,configurable:!0,writable:!0,value:t}):n[o]=t;import"./vendor.f315bbe5.js";import{N as r}from"./mdx-react.modern.e61303d7.js";const i="Deploying Docker on Cloud Foundry",l="Daniel Sinnott",u="https://i.imgur.com/axoBYe2.png",s=25,d=["Golang","Docker","IBMCloud","TravisCI","CI/CD","Cloud Foundry"],p="Fri, 19th Oct 2018",c=new Date(1539960830019);function m(e){var i=e,{components:l}=i,u=((e,a)=>{var r={};for(var i in e)o.call(e,i)&&a.indexOf(i)<0&&(r[i]=e[i]);if(null!=e&&n)for(var i of n(e))a.indexOf(i)<0&&t.call(e,i)&&(r[i]=e[i]);return r})(i,["components"]);return r("wrapper",((e,r)=>{for(var i in r||(r={}))o.call(r,i)&&a(e,i,r[i]);if(n)for(var i of n(r))t.call(r,i)&&a(e,i,r[i]);return e})({components:l},u),r("h2",null,"Using CI and Docker to deploy an application to Cloud Foundry"),r("p",null,"I recently found out Cloud Foundry supports Docker containers, so here quick tutorial of to use\ncontinuous integration to build your application into a docker image and deploy it to Cloud Foundry."),r("h3",null,"Cloud Foundry"),r("p",null,r("a",{href:"https://www.cloudfoundry.org/",parentName:"p"},"Cloud Foundry")," is an open source platform as a service, created by ",r("a",{href:"https://pivotal.io/",parentName:"p"},"Pivotal"),", on which developers\ncan build, deploy, run and scale applications. It can be deployed onto any cloud provider, like AWS\nand is most notably a ",r("a",{href:"https://www.ibm.com/cloud/cloud-foundry",parentName:"p"},"first class citizen")," on IBM Cloud."),r("h3",null,"Docker"),r("p",null,r("a",{href:"https://www.docker.com/",parentName:"p"},"Docker")," is a computer program that performs operating-system-level virtualization, also known as\n\"containerization\". While similar to a Virtual Machine, Docker allows for much less resource\nconsumption as containers share the underlying OS. Like VMs its solves the 'it works on my machine'."),r("h4",null,"Docker images vs Buildpacks"),r("p",null,"CloudFoundry pushes ",r("a",{href:"https://docs.cloudfoundry.org/buildpacks/",parentName:"p"},"Buildpacks")," as their default means for deploying/running an application,\nhowever they also support running container images through their container runtime ",r("a",{href:"https://docs.cloudfoundry.org/concepts/architecture/garden.html",parentName:"p"},"Garden-runC")),r("p",null,"Here's a quick comparison:"),r("table",null,r("thead",{parentName:"table"},r("tr",{parentName:"thead"},r("th",{parentName:"tr"}),r("th",{parentName:"tr"},"Buildpack"),r("th",{parentName:"tr"},"Docker"))),r("tbody",{parentName:"table"},r("tr",{parentName:"tbody"},r("td",{parentName:"tr"},r("strong",{parentName:"td"},"Ease of use")),r("td",{parentName:"tr"},"When you push an app, Cloud Foundry automatically detects an appropriate buildpack for it. Buildpacks typically examine your apps to determine what dependencies to download and how to configure the apps to communicate with bound services. It saves you DevOp time and allows you to focus on you application."),r("td",{parentName:"tr"},"Docker requires an understanding of how to build an image, but once that initial skill cost is paid building and deploying are a breeze.")),r("tr",{parentName:"tbody"},r("td",{parentName:"tr"},r("strong",{parentName:"td"},"Control")),r("td",{parentName:"tr"},"Buildpack's ease comes at the cost of control. Buildpacks have predefined configurations which may not satisfy your needs. Only recently have you been able to combines multiple programming languages together in a single deployment with multibuildpacks"),r("td",{parentName:"tr"},"Docker on the other hand gives full control to the user. You specify exactly what files / services / users / applications you need and they will be included in the image. Images can be build on top of other images, so there's no need to re-invent the wheel")),r("tr",{parentName:"tbody"},r("td",{parentName:"tr"},r("strong",{parentName:"td"},"Portabillity")),r("td",{parentName:"tr"},"Buildpacks can only be run on instances of cloud foundry. While cloud foundry can be run on all the major cloud providers, you may not want to run a full Paas just to deploy an single application."),r("td",{parentName:"tr"},"Docker has much greater portability than buildpacks and are perfect for users who are concerned with vendor lock in. Docker containers can be run anywhere that includes a container runtime, which is all major cloud providers and with the advent of Kubernetes containers have become even more prevalent.")),r("tr",{parentName:"tbody"},r("td",{parentName:"tr"},r("strong",{parentName:"td"},"Security")),r("td",{parentName:"tr"},"A major advantage for buildpacks are that they are maintained by Cloud Foundry and as such their security is kept up date. Major security flaws can also be patched at runtime."),r("td",{parentName:"tr"},"Docker falls behind here a bit. While you can lock down your container to large degree, one eye needs to be kept on keep things up to date. Cloud foundry can't silently update your runtime the way it can with Buildpacks")),r("tr",{parentName:"tbody"},r("td",{parentName:"tr"},r("strong",{parentName:"td"},"Debugging")),r("td",{parentName:"tr"},"Since a lot of the control of whats run is taken away from the user, debugging deployment issues can be more difficult. Though Cloud Foundry does provide some tools to help, such as VMs etc"),r("td",{parentName:"tr"},"Docker solves the 'It works on my machine' issue. Whats runs on your machine is what will run on Cloud Foundry")))),r("h3",null,"Before we begin"),r("p",null,"For the following tutorial, you'll need to have installed:"),r("ul",null,r("li",{parentName:"ul"},"Docker"),r("li",{parentName:"ul"},"Golang 1.11+"),r("li",{parentName:"ul"},"Git")),r("p",null,"We'll need accounts on:"),r("ul",null,r("li",{parentName:"ul"},"Github"),r("li",{parentName:"ul"},"TravisCI"),r("li",{parentName:"ul"},"Docker hub"),r("li",{parentName:"ul"},"IBM Cloud (to use their cloud foundry)")),r("p",null,"The code for this tutorial can be found ",r("a",{href:"https://github.com/sinnott74/DockerCloudFoundryDemo",parentName:"p"},"here"),"."),r("h3",null,"Setting up our Git repo"),r("p",null,"After creating accounts on all of the above. Create a repository on Github for our application."),r("p",null,"Firstly, create a directory for the project. I'll be calling mine ",r("inlineCode",{parentName:"p"},"DockerCloudFoundryDemo"),". Then run\nthe following commands:"),r("ul",null,r("li",{parentName:"ul"},r("inlineCode",{parentName:"li"},"git init")," - to initialise this as a git repository"),r("li",{parentName:"ul"},r("inlineCode",{parentName:"li"},"git remote add origin https://github.com/[username]/DockerCloudFoundryDemo.git")," - to wire up\nour local repo to Github's hosted repo.")),r("h3",null,"Setting up Travis"),r("p",null,"Head over to ",r("a",{href:"https://travis-ci.org",parentName:"p"},"TravisCI")," and navigate to your settings. From there you can configure which Github\nproject's Travis will add a webhook for. On each commit to that repo Travis will run you CI code.\nFor later in the tutorial we'll also need a few enviroment variables set. These are set on a per\nrepo basis."),r("p",null,"The following EnvVars are needed:\n",r("img",{src:"https://i.imgur.com/qYzqpli.png",alt:"TravisCI Environment Variables",title:"TravisCI Environment Variables",parentName:"p"})),r("h3",null,"Our application"),r("p",null,"Our application is a simple ",r("a",{href:"https://golang.org/",parentName:"p"},"Go")," hello world web application. It listens on a port specified by the\nenvironment variable ",r("inlineCode",{parentName:"p"},"PORT")," and returns ",r("inlineCode",{parentName:"p"},"hello world"),". We'll be using Go Modules for this, just to\nshow how you would go about it but this application so simple that no dependencies are needed."),r("p",null,"Running ",r("inlineCode",{parentName:"p"},"go mod init")," will initialise this as a go module project and create a ",r("inlineCode",{parentName:"p"},"go.mod")," file."),r("pre",null,r("code",{className:"language-go",parentName:"pre"},'// main.go\npackage main\n\nimport (\n        "net/http"\n        "os"\n)\n\n// Application entry point\nfunc main() {\n        http.HandleFunc("/", helloWorld)\n        err := http.ListenAndServe(":"+port(), nil)\n        if err != nil {\n                panic(err)\n        }\n}\n\n// Hello world http handler\nfunc helloWorld(w http.ResponseWriter, r *http.Request) {\n        w.WriteHeader(http.StatusOK)\n        w.Write([]byte("Hello world"))\n}\n\n// retrieves the Port to start the server on\nfunc port() string {\n        port := os.Getenv("PORT")\n        if port == "" {\n                port = "8008"\n        }\n        return port\n}\n\n')),r("p",null,"To quickly verify the above code works, run ",r("inlineCode",{parentName:"p"},"go run main.go")," and the visit ",r("inlineCode",{parentName:"p"},"localhost:8008/")," to see\n",r("inlineCode",{parentName:"p"},"Hello world")),r("h3",null,"Build our Docker image"),r("p",null,"Building a Go docker image is much simpler than I have laid out below. I'm building an image which\nis as small as I can make it and have rebuilds that a quick and repeatable."),r("p",null,"The below ",r("inlineCode",{parentName:"p"},"Dockerfile")," is a multi stage build. In the first stage I'll use ",r("inlineCode",{parentName:"p"},"golang:1.11.1-alpine3.8"),"\nas my base as it has the majority of what we need already included."),r("p",null,"Docker builds images in layers. Each command creates a new layer on to of the old one. This allows\nfor faster repeatable builds because we don't need to rebuild layers that haven't change. As such\nyou should put the layers that are most likely to change last."),r("pre",null,r("code",{className:"language-docker",parentName:"pre"},'# Dockerfile\nFROM golang:1.11.1-alpine3.8 as builder\nENV GO111MODULE on\nWORKDIR $GOPATH/src/github.com/sinnott74/DockerCloudFoundryDemo\n\n# Go requires Git to download dependencies\nRUN apk add git\n\n# Copy our module definition\nCOPY go.mod ./\n\n# Download module dependencies\nRUN go mod download\n\n# Copy source files - this is the layer most likely to change\nCOPY . ./\n\n# Build binary, specifying the architecture we want and removing debugging information with the -w -s build flags\nRUN CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -ldflags="-w -s"\n\nFROM alpine:3.8\n\n# Choose port to expose\nEXPOSE 8008\n\n# Copy binary\nCOPY --from=builder /go/src/github.com/sinnott74/DockerCloudFoundryDemo/DockerCloudFoundryDemo .\nCMD ["./DockerCloudFoundryDemo"]\n')),r("p",null,"To build the image run ",r("inlineCode",{parentName:"p"},"docker build -t sinnott74/dockercloudfoundrydemo ."),". Don't forget the ",r("inlineCode",{parentName:"p"},".")," at\nthe end as its specifies which directory to use. Docker images are tagged with the ",r("inlineCode",{parentName:"p"},"-t")," flag which\nprovides a way for use to reference them later."),r("p",null,"To run the image, ",r("inlineCode",{parentName:"p"},"docker run -p 8008:8008 sinnott74/dockercloudfoundrydemo"),". ",r("inlineCode",{parentName:"p"},"-p 8008:8008")," tells\ndocker to map the 8008 port on my local network to 8008 in the container."),r("p",null,"Again visit ",r("inlineCode",{parentName:"p"},"localhost:8008/")," to verify it worked and see ",r("inlineCode",{parentName:"p"},"Hello world")),r("h3",null,"Defining a Cloud Foundry application"),r("p",null,"Cloud Foundry uses ",r("inlineCode",{parentName:"p"},"yaml")," files to define an application. Below we are specifying:"),r("ul",null,r("li",{parentName:"ul"},"The name of the application"),r("li",{parentName:"ul"},"How many instances we want to run"),r("li",{parentName:"ul"},"The memory and disk size required"),r("li",{parentName:"ul"},"The url we want for the application (bare in mind this could be taken)"),r("li",{parentName:"ul"},"Finally, and most importantly the docker image we want to deploy. Cloud foundry will get the\nimage from DockerHub and deploy it.")),r("p",null,"See ",r("a",{href:"https://docs.cloudfoundry.org/devguide/deploy-apps/manifest.html',",parentName:"p"},"Deploying with Application Manifests")," for more configuration options."),r("pre",null,r("code",{className:"language-yaml",parentName:"pre"},"# manifest.yml\napplications:\n    - name: DockerCloudFoundryDemo\n      memory: 32M\n      instances: 1\n      disk_quota: 32M\n      routes:\n          - route: DockerCloudFoundryDemo.eu-gb.mybluemix.net\n      docker:\n          image: sinnott74/dockercloudfoundrydemo\n")),r("h3",null,"Continuous delivery"),r("p",null,"TravisCI is configured with a ",r("inlineCode",{parentName:"p"},".travis.yml")," file. The following file:"),r("ul",null,r("li",{parentName:"ul"},"Builds our binary then runs our tests."),r("li",{parentName:"ul"},"Builds our Docker image"),r("li",{parentName:"ul"},"Pushes the image to DockerHub"),r("li",{parentName:"ul"},"Deploys that images to IBM's Cloud Foundry.")),r("pre",null,r("code",{className:"language-yaml",parentName:"pre"},'# .travis.yml\nlanguage: go\n\ngo:\n    - 1.11.x\n\nenv:\n    - GO111MODULE=on\n\nservices:\n    - docker\n\nscript:\n    # Build binary and run test\n    - go build && go test -v -race ./...\n    # Build docker image\n    - docker build -t sinnott74/dockercloudfoundrydemo .\n\nbefore_deploy:\n    # Login to docker hub\n    - echo "$DOCKER_PASSWORD" | docker login -u "$DOCKER_USER" --password-stdin\n    # Push image to docker\n    - docker push sinnott74/dockercloudfoundrydemo\n\n    # Deploy\n    # Bluemix / IBM Cloud\ndeploy:\n    - provider: cloudfoundry\n      username: ${IBM_CLOUD_USER}\n      #########################\n      ## Add BLUEMIX_PASSWORD environment variable to your Travis project\'s settings\n      ## https://docs.travis-ci.com/user/environment-variables/#Defining-Variables-in-Repository-Settings\n      #########################\n      password: ${IBM_CLOUD_PASSWORD}\n      organization: ${IBM_CLOUD_USER}\n      space: staging\n      region: eu-gb\n      api: https://api.eu-gb.bluemix.net\n')),r("h3",null,"Drum roll please"),r("p",null,"All thats left to do is to commit our changes and push our application to Github."),r("p",null,"Travis will listen for commits on Github and run our CI workload. That workload will verify we can\nbuild the application and that it passes all of our tests. It will then build the Docker image and\npush it to DockerHub, before finally pushing our application to IBM's Cloud Foundry, which will\nretrieve the image from DockerHub and deploy it."),r("p",null,"We can then visit ",r("inlineCode",{parentName:"p"},"DockerCloudFoundryDemo.eu-gb.mybluemix.net")," to see ",r("inlineCode",{parentName:"p"},"Hello world")),r("h4",null,"Voila"),r("img",{src:"https://i.imgur.com/VSXI3WT.png",alt:"Live hello world application",title:"Live hello world application"}),r("p",null,r("strong",{parentName:"p"},"Note:")," I'll probably have taken the above application down by the time you're reading this..."))}m.isMDXComponent=!0;export default m;export{l as author,c as created,p as date,s as id,u as imageurl,d as tags,i as title};
