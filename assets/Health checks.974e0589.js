var e=Object.defineProperty,t=Object.getOwnPropertySymbols,n=Object.prototype.hasOwnProperty,o=Object.prototype.propertyIsEnumerable,r=(t,n,o)=>n in t?e(t,n,{enumerable:!0,configurable:!0,writable:!0,value:o}):t[n]=o;import"./vendor.c97b08d0.js";import{N as a}from"./mdx-react.modern.82e5f5db.js";const i="Health checks",l="Daniel Sinnott",s="https://i.imgur.com/r6PqWEc.png",c=27,h=["Microservices","Golang","GoKit","Cloud Foundry"],p="Tue, 6th Nov 2018",d=new Date(1541545302301);function u(e){var i=e,{components:l}=i,s=((e,r)=>{var a={};for(var i in e)n.call(e,i)&&r.indexOf(i)<0&&(a[i]=e[i]);if(null!=e&&t)for(var i of t(e))r.indexOf(i)<0&&o.call(e,i)&&(a[i]=e[i]);return a})(i,["components"]);return a("wrapper",((e,a)=>{for(var i in a||(a={}))n.call(a,i)&&r(e,i,a[i]);if(t)for(var i of t(a))o.call(a,i)&&r(e,i,a[i]);return e})({components:l},s),a("h2",null,"What is a health check?"),a("p",null,"Health checks are a means to determine whether or not a particular instance of a microservice is\nhealthy and accessible."),a("p",null,"Given the fine grained and horizontally scalable nature of microservices, its not uncommon to have\nhundreds of instances of services running at any one moment. At scale it becomes impractical for an\noperator to keep an eye on service response codes to ensure that everything is running correctly."),a("p",null,"Typically a health check will be implemented as a combination of an endpoint ",a("inlineCode",{parentName:"p"},"/health")," and\ninfrastructure which repeatably hits that endpoint at set intervals. Most modern day infrastructure\nsuch as your orchestrator, load balancer, api gateway or service registry can all cater for this\nkind of monitoring."),a("p",null,"Health checks provide a way for an application to introspect itself and determine if it can operate\ncorrectly. Commonly, this means that an application can connect to its dependencies like a database,\nmessage broker or cache; but it could also go further a determine that its business processes are\nfunctioning correctly."),a("p",null,"If the infrastructure determines that your application is unhealthy, it will kill the instance and\nbring up a new one. You can consider it to be an automated microservice version of the image below."),a("img",{src:"https://i.imgur.com/d4aAK8B.png#1",alt:"We should kill it",title:"We should kill it"}),a("p",null,"Credit to ",a("a",{href:"https://twitter.com/julianwels",parentName:"p"},"@JulianWels")," at ",a("a",{href:"http://ptbd.jwels.berlin",parentName:"p"},"Pretends to be drawing")),a("h2",null,"Implementing a health check"),a("p",null,"We'll add a ",a("inlineCode",{parentName:"p"},"/health")," endpoint to out Todo microservice from the ",a("a",{href:"/blog/26",parentName:"p"},"previous blogpost"),". The source\ncode for the service is on ",a("a",{href:"https://github.com/sinnott74/TodoService",parentName:"p"},"Github"),". Our health endpoint will introspect the service and return a\nhttp ",a("inlineCode",{parentName:"p"},"200")," if everything is ok, otherwise its unhealthy and should be stopped."),a("pre",null,a("code",{className:"language-go",parentName:"pre"},"// service.go\ntype TodoService interface {\n    GetAllForUser(ctx context.Context, username string) ([]Todo, error)\n    GetByID(ctx context.Context, id string) (Todo, error)\n    Add(ctx context.Context, todo Todo) (Todo, error)\n    Update(ctx context.Context, id string, todo Todo) error\n    Delete(ctx context.Context, id string) error\n    Health(ctx context.Context) error\n}\n")),a("p",null,"Next we'll add the implementation for our in memory service. Typically a health check would contains\nsome network request pinging dependencies like a database. e.g."),a("pre",null,a("code",{className:"language-go",parentName:"pre"},"// Health perform service health check. verifies that DB is accessible\nfunc (s *postgresService) Health(ctx context.Context) error {\n    return s.db.PingContext(ctx)\n}\n")),a("p",null,"But since our TodoService is in memory we'll perform a business process health check, by adding then\nretrieving and finally deleting a Todo."),a("pre",null,a("code",{className:"language-go",parentName:"pre"},'// service.go\n// Health check the In memory TodoService business process\nfunc (s *inmemService) Health(ctx context.Context) error {\n    todo := Todo{}\n    addedTodo, err := s.Add(ctx, todo)\n    if err != nil {\n        return err\n    }\n    retrievedTodo, err := s.GetByID(ctx, addedTodo.ID)\n    if err != nil {\n        return err\n    }\n    if addedTodo != retrievedTodo {\n        return errors.New("health check error retrieving todo")\n    }\n    return s.Delete(ctx, addedTodo.ID)\n}\n')),a("p",null,"We would then create an endpoint in our ",a("inlineCode",{parentName:"p"},"endpoint.go")," like we did for the other service methods. Our\n",a("inlineCode",{parentName:"p"},"HealthEndpoint")," won't have any fields in its request or response structs. You could include any\nhealth information you wanted in the response, for example the network response times of\ndependencies, but just as long as your health check infrastructure knows hows to interpret it."),a("pre",null,a("code",{className:"language-go",parentName:"pre"},"// endpoint.go\ntype HealthRequest struct {\n}\n\ntype HealthResponse struct {\n}\n\nfunc MakeHealthEndpoint(s TodoService) endpoint.Endpoint {\n    return func(ctx context.Context, request interface{}) (interface{}, error) {\n        err := s.Health(ctx)\n        return HealthResponse{}, err\n    }\n}\n")),a("p",null,"Finally we add out out http transport endpoint. You may remember from the previous blogpost that\n",a("inlineCode",{parentName:"p"},"encodeResponse")," will return a ",a("inlineCode",{parentName:"p"},"non 2xx")," http status if an error is returned from the endpoint."),a("pre",null,a("code",{className:"language-go",parentName:"pre"},'// transport.go\nrouter.Get("/health", httptransport.NewServer(\n    endpoints.HealthEndpoint,\n    decodeHealthRequest,\n    encodeResponse,\n    options...,\n).ServeHTTP)\n')),a("h2",null,"Configuring health checks on Cloud Foundry"),a("p",null,"Cloud foundry's infrastructure can perform application monitoring to determine if the app should be\nrestarted or not. By default it will check that your app can receive connection on a its specified\n",a("inlineCode",{parentName:"p"},"PORT"),", which is a sensible default as adding your http listener is typically the last thing you'll\ndo during application start up. However, it is possible to configure it to use your service's own\nhealth check endpoint."),a("p",null,"This can vedone by adding a ",a("inlineCode",{parentName:"p"},"health-check-type")," of ",a("inlineCode",{parentName:"p"},"http")," and ",a("inlineCode",{parentName:"p"},"health-check-http-endpoint")," of your\nhealth endpoint which in this case is ",a("inlineCode",{parentName:"p"},"/health")," to your ",a("inlineCode",{parentName:"p"},"manifest.yml"),". Cloud foundry expects a 200\nresponse back within 1 second, otherwise it determines the app to be unhealthy and restarts it. The\ndefault time between every health check is also configurable. It defaults to 60 seconds but it can\nbe configure to be as high a 180s."),a("pre",null,a("code",{className:"language-yaml",parentName:"pre"},"applications:\n    - path: .\n      name: TodoService\n      command: ./TodoService\n      buildpack: https://github.com/cloudfoundry/binary-buildpack.git\n      # Add health checks below\n      health-check-type: http\n      health-check-http-endpoint: /health\n")),a("p",null,"For more info see ",a("a",{href:"https://docs.cloudfoundry.org/devguide/deploy-apps/healthchecks.html#setting_health_checks",parentName:"p"},"Cloud Foundy health checks")),a("p",null,"The result of above is that a http request is sent to ",a("inlineCode",{parentName:"p"},"/health")," every 60 seconds:"),a("pre",null,a("code",{parentName:"pre"},'2018-11-06T22:36:43.46+0000 [APP/PROC/WEB/0] OUT 2018/11/06 22:36:43 "GET http://10.244.98.13:8080/health HTTP/1.1" from 10.244.98.13:60738 - 200 3B in 28.646µs\n2018-11-06T22:37:13.61+0000 [APP/PROC/WEB/0] OUT 2018/11/06 22:37:13 "GET http://10.244.98.13:8080/health HTTP/1.1" from 10.244.98.13:33370 - 200 3B in 43.844µs\n2018-11-06T22:37:43.78+0000 [APP/PROC/WEB/0] OUT 2018/11/06 22:37:43 "GET http://10.244.98.13:8080/health HTTP/1.1" from 10.244.98.13:34150 - 200 3B in 39.904µs\n2018-11-06T22:38:14.20+0000 [APP/PROC/WEB/0] OUT 2018/11/06 22:38:14 "GET http://10.244.98.13:8080/health HTTP/1.1" from 10.244.98.13:35090 - 200 3B in 27.417µs\n2018-11-06T22:38:44.44+0000 [APP/PROC/WEB/0] OUT 2018/11/06 22:38:44 "GET http://10.244.98.13:8080/health HTTP/1.1" from 10.244.98.13:35990 - 200 3B in 36.033µs\n2018-11-06T22:39:14.63+0000 [APP/PROC/WEB/0] OUT 2018/11/06 22:39:14 "GET http://10.244.98.13:8080/health HTTP/1.1" from 10.244.98.13:36920 - 200 3B in 26.526µs\n2018-11-06T22:39:44.84+0000 [APP/PROC/WEB/0] OUT 2018/11/06 22:39:44 "GET http://10.244.98.13:8080/health HTTP/1.1" from 10.244.98.13:37798 - 200 3B in 28.486µs\n2018-11-06T22:40:14.99+0000 [APP/PROC/WEB/0] OUT 2018/11/06 22:40:14 "GET http://10.244.98.13:8080/health HTTP/1.1" from 10.244.98.13:38630 - 200 3B in 26.447µs\n2018-11-06T22:40:45.45+0000 [APP/PROC/WEB/0] OUT 2018/11/06 22:40:45 "GET http://10.244.98.13:8080/health HTTP/1.1" from 10.244.98.13:39526 - 200 3B in 25.073µs\n2018-11-06T22:41:15.66+0000 [APP/PROC/WEB/0] OUT 2018/11/06 22:41:15 "GET http://10.244.98.13:8080/health HTTP/1.1" from 10.244.98.13:40472 - 200 3B in 84.141µs\n2018-11-06T22:41:45.86+0000 [APP/PROC/WEB/0] OUT 2018/11/06 22:41:45 "GET http://10.244.98.13:8080/health HTTP/1.1" from 10.244.98.13:41356 - 200 3B in 26.716µs\n2018-11-06T22:42:16.06+0000 [APP/PROC/WEB/0] OUT 2018/11/06 22:42:16 "GET http://10.244.98.13:8080/health HTTP/1.1" from 10.244.98.13:42286 - 200 3B in 27.594µs\n')))}u.isMDXComponent=!0;export default u;export{l as author,d as created,p as date,c as id,s as imageurl,h as tags,i as title};
