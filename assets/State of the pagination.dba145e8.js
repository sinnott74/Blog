var e=Object.defineProperty,n=Object.getOwnPropertySymbols,t=Object.prototype.hasOwnProperty,a=Object.prototype.propertyIsEnumerable,i=(n,t,a)=>t in n?e(n,t,{enumerable:!0,configurable:!0,writable:!0,value:a}):n[t]=a;import"./vendor.c97b08d0.js";import{N as o}from"./mdx-react.modern.82e5f5db.js";const r="State of the pagi-nation",s="Daniel Sinnott",l="https://i.imgur.com/ietahcb.png",p=24,c=["Technical","ReactJS","Pagination"],u="Mon, 10th Sep 2018",d=new Date(1536615936462);function g(e){var r=e,{components:s}=r,l=((e,i)=>{var o={};for(var r in e)t.call(e,r)&&i.indexOf(r)<0&&(o[r]=e[r]);if(null!=e&&n)for(var r of n(e))i.indexOf(r)<0&&a.call(e,r)&&(o[r]=e[r]);return o})(r,["components"]);return o("wrapper",((e,o)=>{for(var r in o||(o={}))t.call(o,r)&&i(e,r,o[r]);if(n)for(var r of n(o))a.call(o,r)&&i(e,r,o[r]);return e})({components:s},l),o("h2",null,"Adding pagination"),o("p",null,"Having recently having added ",o("a",{href:"/blog/22",parentName:"p"},"Hero Images")," to each blogpost, which get displayed on the blog list\npage, the size of this blog has greatly increased."),o("p",null,"Visiting danielsinnott.com will cause 57 requests and 1.2MB to be downloaded. This is unacceptable\nand is a problem that won't scale as the blogposts continue. Currently, every blogpost is displayed\non the list page, causing every hero image to be downloaded."),o("p",null,"The solution to this problem is pagination."),o("h3",null,"Creating a pagination component"),o("p",null,"We'll start this post off with a couple of assumptions."),o("ul",null,o("li",{parentName:"ul"},"You're familiar with react & javascript (I'm going to assume a create react app / react-scripts\nbuild set up)"),o("li",{parentName:"ul"},"You have a react app which need so pagination"),o("li",{parentName:"ul"},"The list of items you want to paginate, has it's own style that you'd like to keep")),o("h4",null,"Create the files"),o("p",null,"Create a Pagination folder & 3 files:"),o("ul",null,o("li",{parentName:"ul"},o("inlineCode",{parentName:"li"},"index.js")),o("li",{parentName:"ul"},o("inlineCode",{parentName:"li"},"Pagination.jsx")),o("li",{parentName:"ul"},o("inlineCode",{parentName:"li"},"Pagination.css")," (or ",o("inlineCode",{parentName:"li"},"scss")," if you've go Sass integrated into your build)")),o("h4",null,"index.js"),o("p",null,"I like to always create an folder for each component and have that folder contain an ",o("inlineCode",{parentName:"p"},"index.js"),". It\nallows for neat grouping of related files but also take care of keeping the import of the component\nshort as modules which import this component will automatically look for index.js when importing\nfrom a directory. e.g:"),o("pre",null,o("code",{className:"language-jsx",parentName:"pre"},'import Pagination from "src/components/Pagination";\n')),o("p",null,"Our index.js is a simple a redirect file, that imports our component and then exports it:"),o("pre",null,o("code",{className:"language-jsx",parentName:"pre"},'// index.js\nimport Pagination from "./Pagination";\nexport default Pagination;\n')),o("h4",null,"Defining our Pagination.jsx"),o("p",null,"I always begin a component by writing a skeleton & defining the component's input:"),o("pre",null,o("code",{className:"language-jsx",parentName:"pre"},'// Pagination.jsx\nimport React from "react";\nimport PropTypes from "prop-types";\nimport "./Pagination.css";\n\nexport default class Pagination extends React.Component {\n    constructor(props) {}\n    render() {}\n}\n\nPagination.propTypes = {\n    itemsPerPage: PropTypes.number.isRequired,\n    className: PropTypes.string,\n    children: PropTypes.arrayOf(PropTypes.node).isRequired,\n};\n')),o("p",null,"We've outlines a basic react component and with our ",o("inlineCode",{parentName:"p"},"PropTypes")," have documented that the component\ntakes in a number ",o("inlineCode",{parentName:"p"},"itemsPerPage"),", a ",o("inlineCode",{parentName:"p"},"className")," which will will add to our paginated list and\nfinally ",o("inlineCode",{parentName:"p"},"children")," which will be the items we are paginating."),o("h4",null,"Displaying our items"),o("p",null,"Lets add the code to display our reduced/paged list of items. We're ",o("inlineCode",{parentName:"p"},"props.children")," as our generic\nlist of items to display. In the code below, we've added our ",o("inlineCode",{parentName:"p"},"state")," which storing only our\n",o("inlineCode",{parentName:"p"},"currentPage"),"."),o("p",null,"During ",o("inlineCode",{parentName:"p"},"render"),", we calculate how many pages we'll need and slice our children items array to only\nthe items that should be displayed on that page. We the render our pages items in a ",o("inlineCode",{parentName:"p"},"div")," with the\n",o("inlineCode",{parentName:"p"},"className")," prop so consumers can style the list appropriately."),o("pre",null,o("code",{className:"language-jsx",parentName:"pre"},'// Pagination.jsx\nimport React from "react";\nimport PropTypes from "prop-types";\nimport "./Pagination.css";\n\nexport default class Pagination extends React.Component {\n    constructor(props) {\n        super(props);\n        this.state = {\n            currentPage: 1,\n        };\n    }\n\n    render() {\n        const itemsPerPage = this.props.itemsPerPage || 6;\n        let items = React.Children.toArray(this.props.children);\n        const numPages = Math.round(items.length / itemsPerPage);\n        items = items.slice(\n            (this.state.currentPage - 1) * itemsPerPage,\n            this.state.currentPage * itemsPerPage,\n        );\n        return (\n            <div className="paginate">\n                <div className={this.props.className}>{items}</div>\n            </div>\n        );\n    }\n}\n\nPagination.propTypes = {\n    itemsPerPage: PropTypes.number.isRequired,\n    className: PropTypes.string,\n};\n')),o("h3",null,"Adding page buttons"),o("p",null,"Next, we'll add the buttons for controlling which pages are visible. The class will need some extra\nmethods to user interaction. Below we add 3 methods, and bind them to pagination instance's ",o("inlineCode",{parentName:"p"},"this"),"\nduring the constructor. Add the following snippet:"),o("pre",null,o("code",{className:"language-jsx",parentName:"pre"},"// Pagination.jsx\nexport default class Pagination extends React.Component {\n  constructor(props) {\n    ...\n    this._onPreviousClick = this._onPreviousClick.bind(this);\n    this._onNextClick = this._onNextClick.bind(this);\n    this._setCurrentPage = this._setCurrentPage.bind(this);\n  }\n  ...\n  _onPreviousClick() {\n    this._setCurrentPage(this.state.currentPage - 1);\n  }\n\n  _onNextClick() {\n    this._setCurrentPage(this.state.currentPage + 1);\n  }\n\n  _setCurrentPage(page) {\n    if (page === this.state.currentPage) return;\n    this.setState({\n      currentPage: page\n    });\n  }\n  ...\n}\n")),o("p",null,"Next, we'll add the buttons to the DOM. Like previous blogposts, we'll be using the ",o("a",{href:"https://react-md.mlaursen.com/",parentName:"p"},"React-MD"),"\ncomponent library, whose ",o("inlineCode",{parentName:"p"},"import")," can be seen at the top of the snippet below. Then during ",o("inlineCode",{parentName:"p"},"render"),"\nwe check if we should be disabling the previous or next buttons, if we're on the first or last page\nrespectively."),o("pre",null,o("code",{className:"language-jsx",parentName:"pre"},'// Pagination.jsx\n...\nimport Button from "react-md/lib/Buttons/Button";\n\nexport default class Pagination extends React.Component {\n  ...\n  render() {\n    ...\n    const previousDisabled = this.state.currentPage === 1 ? true : false;\n    const nextDisabled = this.state.currentPage === numPages ? true : false;\n\n    let pageButtons = [];\n    for (let i = 1; i <= numPages; i++) {\n      const isCurrent = i === this.state.currentPage ? true : false;\n      pageButtons.push(\n        <Button\n          flat={!isCurrent}\n          raised={isCurrent}\n          primary={isCurrent}\n          onClick={() => this.setCurrentPage(i)}\n          key={i}\n        >\n          {i}\n        </Button>\n      );\n    }\n\n    return (\n      <div className="paginate">\n        <div className={this.props.className}>{items}</div>\n        <div className="paginate__buttons">\n          <Button\n            icon\n            className="paginate__buttons-left"\n            tooltipLabel="Previous"\n            tooltipPosition="top"\n            tooltipDelay={1000}\n            disabled={previousDisabled}\n            onClick={this._onPreviousClick}\n          >\n            chevron_left\n          </Button>\n          <div className="paginate__numbuttons">{pageButtons}</div>\n          <Button\n            icon\n            className="paginate__buttons-right"\n            tooltipLabel="Next"\n            tooltipPosition="top"\n            tooltipDelay={1000}\n            disabled={nextDisabled}\n            onClick={this._onNextClick}\n          >\n            chevron_right\n          </Button>\n        </div>\n      </div>\n    );\n  }\n  ...\n')),o("h4",null,"Scrolling to the top of the page"),o("p",null,"When the user changes, page they expect to be brought to the top of the page so they can start read\nfrom the start. Unfortunately, we don't know where the top of the page is as the ",o("inlineCode",{parentName:"p"},"Pagination"),"\ncomponent could be used anywhere. We'll need to calculate it each time."),o("p",null,"To start we'll need a reference to the ",o("inlineCode",{parentName:"p"},"paginate div"),". We do this by creating a ref in the\nconstructor and attaching it during rendering."),o("p",null,"On each page change, we calculate where the top left corner of the ",o("inlineCode",{parentName:"p"},"paginate div")," is and scroll the\nwindow to there."),o("pre",null,o("code",{className:"language-jsx",parentName:"pre"},'// Pagination.jsx\n...\nexport default class Pagination extends React.Component {\n  constructor(props) {\n    ...\n    this.paginateTopRef = React.createRef();\n  }\n\n  render() {\n    ...\n    return (\n      <div className="paginate" ref={this.paginateTopRef}>\n      ...\n    );\n  }\n\n  _setCurrentPage(page) {\n    ...\n    const paginateClientRect = this.paginateTopRef.current.getBoundingClientRect();\n    window.scrollTo(paginateClientRect.x, paginateClientRect.y);\n  }\n}\n...\n')),o("h4",null,"Adding style"),o("p",null,"Finally we add some styles to our buttons to keep them inline and from overflowing:"),o("pre",null,o("code",{className:"language-css",parentName:"pre"},"// Pagination.css\n.paginate__buttons {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    width: 100%;\n}\n\n.paginate__numbuttons {\n    display: inline-flex;\n    overflow: auto;\n}\n")),o("h3",null,"Making a difference"),o("p",null,"Before pagination, loading danielsinnott.com from clean took ",o("strong",{parentName:"p"},"57 requests & 1.2MB")," to download,\nafter adding pagination the page load has been reduced to ",o("strong",{parentName:"p"},"29 requests and only 480KB"),". Thats a\nreduction of over 50% by adding a single component. I'd also argue that beyond the page load\nperformance the user experience has improved."),o("p",null,"The full source for this can be see over at ",o("a",{href:"https://github.com/sinnott74/BlogWebClient/tree/master/src/core/components/Pagination",parentName:"p"},"Github")))}g.isMDXComponent=!0;export default g;export{s as author,d as created,u as date,p as id,l as imageurl,c as tags,r as title};
